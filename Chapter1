#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Apr 20 20:41:21 2023

@author: gene
"""

"""
Exercise 1.1
10
12
8
3
6


19
False
4
16
6
16

Exercise 1.2
/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7))

Exercise 1.3
define (f a b c) (cond (and (< a b) (< a c)) (+ (* b b) (* c c)) (and (< b a) (< b c)) (+ (* a a) (* c c)) (else (+ (* a a) (* b b))))
^ could use sum-of-squares and stuff as well

Exercise 1.4
If b is greater than 0 then the operation is plus, otherwise it is minus. the procedure then returns a [operation] b

Exercise 1.5
If the interpreter uses applicative-order evaluation then the procedure will just return zero. If it uses normal-order evaluation, then the interpreter will try to figure out what y is, which is p, which loops back to itself infinitely, causing a dead loop

Exercise 1.6
When Alyssa attempts to use this to compute square roots, it may get stuck in an infinite loop, as the third argument of new-if is another sqrt-iter, meaning the computer will get stuck in a recursive unending cycle.

Exercise 1.7
Because good-enough uses a constant error, it will fail for small numbers. If, say, the error allowance is 0.001, then if the answer is 0.00001, then a guess could be 100 times the correct answer and good-enough would still return true! For large numbers, any iterative process may go in jumps too large for good enough. A guess may cycle between 100 and 101, always more than the error of 0.01 from the correct answer 100.5
Here is an implemented square root function that uses the decreasing change in "guess" to determine if the guess is good enough:
"""
def goodenough (guess, x, lastguess):
    if (abs((guess - lastguess)/guess) < 0.01):
        return True
    return False

def sqriter (guess, x, lastguess):
    # print(str(guess) + ", " + str(x) + ", " + str(lastguess))
    if (goodenough(guess, x, lastguess)):
        return guess
    else:
        return sqriter(0.5*(guess+x/guess), x, guess)
        
def sqrter (x):
    if (x<0):
        print("No square rooting negatives")
        return
    return sqriter(1,x,2*x)

#print(sqrter(19239))  # correct is 138.7
#print(sqrter(0.0001)) # correct is 0.01

"""
Exercise 1.8
"""
def cbiter (guess, x, lastguess):
    if (goodenough(guess, x, lastguess)):
        return guess
    else:
        return cbiter((2*guess+x/guess**2)/3, x, guess)
def cbrter (x):
    return cbiter(1,x,2*x)
#print(cbrter(27))
#print(cbrter(-1))

"""
Exercise 1.9
Method one: (+ 4 5) -> inc (+ 3 5) -> inc(inc(+ 2 5)) -> inc(inc(inc(+ 1 5))) -> inc(inc(inc(inc(+ 0 5)))) -> inc^4(5) -> inc^3(6) -> inc^2(7) -> inc(8) -> inc(9)
Method two: (+ 4 5) -> (+ 3 6) -> (+ 2 7) -> (+ 1 8) -> (+ 0 9) -> 9

Recursive since it calls itself
"""

"""
Exercise 1.10

Hand Calculation:
A(1,10) = A(0,A(1,9)) = 2*A(1,9) = 4*A(1,8) ... = 512*A(1,1) = 1024
A(2,4) = A(1,A(2,3)) = 2**A(2,3) = 2**2**A(2,2) = 2**2**2**A(2,1) = 2**2**2**2 = 2^16 = 65536
A(3,3) = A(2,A(3,2)) = A(2,A(2,A(3,1))) = A(2,A(2,2)) = A(2,4) = 65536

Just to check:
"""
def A(x,y):
    if y==0:
        return 0
    if x==0:
        return 2*y
    if y==1:
        return 2
    else:
        return A(x-1, A(x,y-1))

# print(A(1,10))
# print(A(2,4))
# print(A(3,3))

"""
Mathematical expressions:
(define (f n) (A 0 n)) = 2*n
(define (g n) (A 1 n)) = 2**n
(define (h n) (A 2 n)) = 2**2**2...**2 n times
(define (k n) (* 5 n n)) = 5n^2
"""
        
"""
Exercise 1.11
"""
def recursivef(n):
    if n<3:
        return n
    return recursivef(n-1)+2*recursivef(n-2)+3*recursivef(n-3)

def fiter(n,i,oneprev,twoprev,threeprev):
    if n==i:
        return oneprev + 2*twoprev + 3*threeprev
    else:
        return fiter(n, i+1, oneprev + 2*twoprev + 3*threeprev, oneprev, twoprev)
    
def iterativef(n):
    if n<3:
        return n
    return fiter(n,3,2,1,0)

"""
Exercise 1.12
"""
def recursivePascal(i,j):
    if i == 0: # first row
        return 1
    if j == 0: # left column
        return 1
    if i == j:
        return 1
    else:
        return recursivePascal(i-1,j-1) + recursivePascal(i-1,j)

#print(recursivePascal(6,3))

"""
Exercise 1.13

First it is easy to check that the base cases work: Fib(0) and Fib(1) both do what they're supposed to
Now assume that Fib(k)=(phi^k-psi^k)/sqrt(5) for all k from 1 to n-1. 
Now, Fib(n) = Fib(n-1)+Fib(n-2) by definition. Plugging in the formula from the inductive hypothesis, we get:
    Fib(n) = (phi^(n-1)+phi^(n-2)-psi^(n-1)-psi^(n-2))/sqrt(5). Expand and simplify and we get 
    Fib(n) = (phi^n-psi^n)/sqrt(5), as desired. Now since psi<1 as n gets large psi goes to zero, and since all Fibonacci numbers are the sum of integers and therefore integers, Fib(n) must be the closest integer to phi^n/sqrt(5)
"""

"""
Exercise 1.14

count-change(11) = count-change(11 without pennies) + count-change(10) = count-change(10) = count-change(10 without pennies) + count-change(9) = count-change(5 without pennies) + count-change(9) = 1 + count-change(9) = 1 + count-change(8) ... = 1 + count-change(5) = 2
"""

"""
Exercise 1.15
a) 7 times because 12.15/3^7<0.01 but 12.15/3^6>0.01
b) on the order of log(a)
"""













